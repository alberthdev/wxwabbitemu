// -*- C++ -*- generated by wxGlade 0.6.3 on Fri Aug 27 01:31:51 2010

#include "wxgui_lcd.h"

// begin wxGlade: ::extracode
// end wxGlade



wxWabbitemu_LCD::wxWabbitemu_LCD(wxWindow* parent, int id, const wxString& title, const wxPoint& pos, const wxSize& size, long style):
    wxFrame(parent, id, title, pos, size, wxDEFAULT_FRAME_STYLE)
{
    // begin wxGlade: wxWabbitemu_LCD::wxWabbitemu_LCD
    panel_1 = new wxPanel(this, wxID_ANY);
    label_1 = new wxStaticText(panel_1, wxID_ANY, wxT("Loading wxWabbitEmu..."));
    wabbitemu_Timer = (wxTimer *) NULL;

    set_properties();
    do_layout();
    // end wxGlade
}


void wxWabbitemu_LCD::set_properties()
{
    // begin wxGlade: wxWabbitemu_LCD::set_properties
    SetTitle(wxT("wxWabbitemu - LCD"));
    label_1->SetFont(wxFont(10, wxDEFAULT, wxNORMAL, wxBOLD, 0, wxT("")));
    // end wxGlade
}


void wxWabbitemu_LCD::do_layout()
{
    // begin wxGlade: wxWabbitemu_LCD::do_layout
    wxBoxSizer* sizer_1 = new wxBoxSizer(wxVERTICAL);
    wxFlexGridSizer* grid_sizer_1 = new wxFlexGridSizer(1, 1, 0, 0);
    grid_sizer_1->Add(label_1, 0, wxADJUST_MINSIZE, 0);
    panel_1->SetSizer(grid_sizer_1);
    grid_sizer_1->AddGrowableRow(0);
    grid_sizer_1->AddGrowableCol(0);
    sizer_1->Add(panel_1, 1, wxEXPAND, 0);
    SetSizer(sizer_1);
    sizer_1->Fit(this);
    //make us a new timer :D
    wabbitemu_Timer = new wxTimer(this, wxWabbitemu_Timer);
    Layout();
    // end wxGlade
}

void wxWabbitemu_LCD::OnTimer(wxTimerEvent& WXUNUSED(event))
{
	static int difference;
	static struct timeval prevTimer;
	struct timeval time;
	gettimeofday(&time, NULL);
	

	// How different the timer is from where it should be
	// guard from erroneous timer calls with an upper bound
	// that's the limit of time it will take before the
	// calc gives up and claims it lost time
	difference += ((time.tv_sec - prevTimer.tv_sec) & 0x003F) - TPF;
	prevTimer = time;
	//this is for updating the progress bar
	//we will use this later
	/*int i;
	for (i = 0; i < MAX_CALCS; i++) {
		if (calcs[i].active && calcs[i].send == TRUE) {
			static int frameskip = 0;
			frameskip = (frameskip + 1) % 3;

			if (frameskip == 0) {
				extern HWND hwndSend;
				SendMessage(hwndSend, WM_USER, 0, 0);
				difference = 0;
				return;
			}
		}
	}*/

	// Are we greater than Ticks Per Frame that would call for
	// a frame skip?
	if (difference > -TPF) {
		calc_run_all();
		while (difference >= TPF) {
			calc_run_all();
			difference -= TPF;
		}

		int i;
		for (i = 0; i < MAX_CALCS; i++) {
			if (calcs[i].active) {
				gui_draw(i);
			}
		}
	// Frame skip if we're too far ahead.
	} else difference += TPF;
}



void wxWabbitemu_LCD::OnPaint(wxPaintEvent& event)
{
	wxPaintDC paintDC(this);
	PaintLCD((wxWindow *) this, paintDC);
	//TODO: add in fps counter in the status bar
	//LCD_t *lcd = calcs[gslot].cpu.pio.lcd;
}

void wxWabbitemu_LCD::PaintLCD(wxWindow *window, wxPaintDC wxDCDest)
{
	unsigned char *screen;
	LCD_t *lcd = calcs[gslot].cpu.pio.lcd;
	wxSize rc = GetClientSize();			//GetClientRect(calcs[gslot].hwndLCD, &rc);

	wxClientDC wxDC(window), wxDCOverlay;
	wxMemoryDC wxMemDC;
	if (wxDC == NULL) {
		printf("Creating buffer DC failed\n");
		return;
	} /*else {
		if (bmpBuf == NULL)
			printf("Creating bitmap failed\n");
		wxMemDC.SelectObject(bmpBuf);
	}*/

	if (lcd->active == FALSE) {
		BYTE lcd_data[128*64];
		memset(lcd_data, 0, sizeof(lcd_data));
		//for (i = 0; i < 128*64; i++) lcd_data[i]=0x00; //whitest pixel

		wxBitmap bmpBuf(&lcd_data, wxBITMAP_TYPE_XBM, rc.GetWidth(), rc.GetHeight(), -1);
		/*if (wxBitmap.Create(lcd_data, wxBitmap StretchDIBits(
			hdc,
			rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
			0, 0, lcd->width, 64,
			lcd_data,
			bi,
			DIB_RGB_COLORS,
			SRCCOPY) == 0) {

			printf("error in SetDIBitsToDevice\n");
		}*/
		wxMemDC.SelectObject(bmpBuf);

		//draw drag panes
		/*if (calcs[gslot].do_drag == TRUE) {

			hdcOverlay = DrawDragPanes(hwnd, hdcDest, 0);
			BLENDFUNCTION bf;
			bf.BlendOp = AC_SRC_OVER;
			bf.BlendFlags = 0;
			bf.SourceConstantAlpha = 160;
			bf.AlphaFormat = 0;
			if (AlphaBlend(	hdc, 0, 0, rc.right, rc.bottom,
						hdcOverlay, 0, 0, rc.right, rc.bottom,
						bf ) == FALSE) printf("alpha blend 1 failed\n");

			DeleteDC(hdcOverlay);

		}*/

		//copy to the screen
		wxMemDC.Blit(rc.x, rc.y, rc.GetWidth(), rc.GetHeight(), &wxDCDest, 0, 0);
		/*if (BitBlt(	hdcDest, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
			hdc, 0, 0, SRCCOPY ) == FALSE) printf("BitBlt failed\n");*/

	} else {
		screen = LCD_image( calcs[gslot].cpu.pio.lcd ) ;
		//screen = GIFGREYLCD();

		//this is for the 86, so it doesnt look like complete shit
		/*if (lcd->width * calcs[gslot].Scale != (rc.right - rc.left))
			SetStretchBltMode(hdc, HALFTONE);
		else
			SetStretchBltMode(hdc, BLACKONWHITE);*/
		wxBitmap bmpBuf(&screen, wxBITMAP_TYPE_XBM, rc.GetWidth(), rc.GetHeight(), -1);
		/*if (StretchDIBits(	hdc,
							rc.left, rc.top, rc.right - rc.left,  rc.bottom - rc.top,
							0, 0, lcd->width, 64,
							screen,
							bi,
							DIB_RGB_COLORS,
							SRCCOPY) == 0) {
							printf("error in SetDIBitsToDevice\n");
						}*/


		//if were dragging something we will draw these nice panes
		/*BLENDFUNCTION bf;
		bf.BlendOp = AC_SRC_OVER;
		bf.BlendFlags = 0;
		bf.SourceConstantAlpha = 160;
		bf.AlphaFormat = 0;

		if (calcs[gslot].do_drag == TRUE) {

			hdcOverlay = DrawDragPanes(hwnd, hdcDest, 0);

			if (AlphaBlend(	hdc, 0, 0, rc.right, rc.bottom,
						hdcOverlay, 0, 0, rc.right, rc.bottom,
						bf ) == FALSE) printf("alpha blend 1 failed\n");

			DeleteDC(hdcOverlay);

		}*/


		//if were sending something we can draw the sending shtuff
		/*if (calcs[gslot].send == TRUE) {
			bf.SourceConstantAlpha = 192;
			hdcOverlay = DrawSending(hwnd, hdcDest);

			if (AlphaBlend(	hdc, 0, 0, rc.right, rc.bottom,
						hdcOverlay, 0, 0, rc.right, rc.bottom,
						bf ) == FALSE) printf("alpha blend send failed\n");

			DeleteDC(hdcOverlay);
		}*/

		//this alphablends the skin to the screen making it look nice
		/*bf.SourceConstantAlpha = 108;

		POINT pt;
		pt.x = rc.left;
		pt.y = rc.top;
		ClientToScreen(hwnd, &pt);
		ScreenToClient(GetParent(hwnd), &pt);

		if (alphablendfail<100 && lcd->width != 138) {
			if (AlphaBlend(	hdc, rc.left, rc.top, rc.right,  rc.bottom,
				calcs[gslot].hdcSkin, calcs[gslot].rectLCD.left, calcs[gslot].rectLCD.top,
				(rc.right - rc.left), 128,
					bf )  == FALSE){
				//printf("alpha blend 2 failed\n");
				alphablendfail++;
			}
		}*/

		//finally copy up the screen image
		wxMemDC.Blit(rc.x, rc.y, rc.GetWidth(), rc.GetHeight(), &wxDCDest, 0, 0);
		/*if (BitBlt(	hdcDest, rc.left, rc.top, rc.right - rc.left,  rc.bottom - rc.top,
			hdc, 0, 0, SRCCOPY ) == FALSE) printf("Bit blt failed\n");*/

	}
	//delete wxBitmap;				//DeleteObject(bmpBuf);
	//delete &wxMemDC; 				//DeleteDC(hdc);
}


